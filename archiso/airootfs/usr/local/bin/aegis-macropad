#!/usr/bin/env python3
"""
Aegis Macropad - GTK4/Libadwaita Macro Button Controller
A beautiful macro button interface with Catppuccin theming.
Works with Stream Deck devices and virtual macropads.
Features customizable icons, lighting preset integration, and full edit mode.
"""

import gi
gi.require_version('Gtk', '4.0')
gi.require_version('Adw', '1')
from gi.repository import Gtk, Adw, GLib, Gio, GdkPixbuf
import json
import subprocess
from pathlib import Path
from dataclasses import dataclass, asdict
from typing import Optional, List, Dict, Any

# Import shared Aegis GTK library
from aegis_gtk import (
    COLORS,
    ACCENT_COLORS,
    LIGHT_COLORS,
    setup_css,
    run_in_thread,
    needs_dark_text,
    LightingPresetAPI,
    ColorPickerRow,
    EmojiPicker,
    IconPicker,
    IconPickerDialog,
)

# App-specific CSS additions
APP_CSS = f"""
.deck-panel {{
    background-color: {COLORS['mantle']};
    border-radius: 16px;
    padding: 24px;
    border: 2px solid {COLORS['surface0']};
}}
.button-icon-image {{
    margin-bottom: 2px;
}}
.edit-btn-active {{
    background-color: {COLORS['mauve']};
    color: {COLORS['crust']};
}}
.icon-preview {{
    background-color: {COLORS['surface0']};
    border-radius: 12px;
    min-width: 72px;
    min-height: 72px;
}}
"""


@dataclass
class DeckButton:
    """Represents a macro button configuration."""
    icon: str
    icon_type: str  # "emoji", "icon_name", "file_path"
    label: str
    color: str
    action: str = ""
    action_type: str = "command"  # "command", "hotkey", "text", "lighting_preset"
    lighting_preset_id: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'DeckButton':
        # Handle legacy format without icon_type
        if 'icon_type' not in data:
            data['icon_type'] = 'emoji'
        return cls(
            icon=data.get('icon', ''),
            icon_type=data.get('icon_type', 'emoji'),
            label=data.get('label', ''),
            color=data.get('color', 'surface'),
            action=data.get('action', ''),
            action_type=data.get('action_type', 'command'),
            lighting_preset_id=data.get('lighting_preset_id')
        )


# Default button layout (5x3 grid)
DEFAULT_BUTTONS = [
    # Row 1
    DeckButton("üî¥", "emoji", "LIVE", "red", "obs-cli start-streaming", "command"),
    DeckButton("üé¨", "emoji", "RECORD", "mauve", "obs-cli start-recording", "command"),
    DeckButton("üì∑", "emoji", "SCENE 1", "blue", "obs-cli set-scene 'Scene 1'", "command"),
    DeckButton("üéÆ", "emoji", "SCENE 2", "teal", "obs-cli set-scene 'Scene 2'", "command"),
    DeckButton("üí¨", "emoji", "SCENE 3", "peach", "obs-cli set-scene 'Scene 3'", "command"),
    # Row 2
    DeckButton("üé§", "emoji", "MIC", "green", "pactl set-source-mute @DEFAULT_SOURCE@ toggle", "command"),
    DeckButton("üîä", "emoji", "MUSIC", "pink", "playerctl play-pause", "command"),
    DeckButton("üåÖ", "emoji", "WARM", "peach", "", "lighting_preset", "warm"),
    DeckButton("üé¨", "emoji", "STUDIO", "yellow", "", "lighting_preset", "studio"),
    DeckButton("‚òÄÔ∏è", "emoji", "DAYLIGHT", "sky", "", "lighting_preset", "daylight"),
    # Row 3
    DeckButton("üéµ", "emoji", "SFX 1", "lavender", "paplay /usr/share/sounds/sfx/sound1.wav", "command"),
    DeckButton("üé∂", "emoji", "SFX 2", "sapphire", "paplay /usr/share/sounds/sfx/sound2.wav", "command"),
    DeckButton("üëè", "emoji", "SFX 3", "flamingo", "paplay /usr/share/sounds/sfx/sound3.wav", "command"),
    DeckButton("üåô", "emoji", "LIGHT OFF", "surface1", "", "lighting_preset", "off"),
    DeckButton("‚öôÔ∏è", "emoji", "CONFIG", "surface1", "", "command"),
]


class ButtonEditDialog(Adw.Window):
    """Dialog for editing a macro button."""

    ACTION_TYPES = [
        ("command", "Shell Command"),
        ("lighting_preset", "Lighting Preset"),
        ("hotkey", "Keyboard Shortcut"),
        ("text", "Text Input"),
    ]

    def __init__(self, parent, button: Optional[DeckButton] = None):
        super().__init__(transient_for=parent, modal=True)
        self.set_title("Edit Button" if button else "New Button")
        self.set_default_size(450, 600)

        self.button_data = button or DeckButton("", "emoji", "", "surface1", "", "command")
        self.result: Optional[DeckButton] = None

        self._build_ui()

    def _build_ui(self):
        setup_css(self)

        main_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=0)
        self.set_content(main_box)

        # Header
        header = Adw.HeaderBar()
        header.add_css_class('header-bar')

        cancel_btn = Gtk.Button(label="Cancel")
        cancel_btn.connect('clicked', lambda b: self.close())
        header.pack_start(cancel_btn)

        save_btn = Gtk.Button(label="Save")
        save_btn.add_css_class('primary-button')
        save_btn.connect('clicked', self._on_save)
        header.pack_end(save_btn)

        main_box.append(header)

        # Scrollable content
        scroll = Gtk.ScrolledWindow()
        scroll.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)
        scroll.set_vexpand(True)
        main_box.append(scroll)

        content = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=16)
        content.add_css_class('dialog-content')
        scroll.set_child(content)

        # Preview section
        preview_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=8)
        preview_box.set_halign(Gtk.Align.CENTER)
        content.append(preview_box)

        preview_label = Gtk.Label(label="Preview")
        preview_label.add_css_class('section-title')
        preview_box.append(preview_label)

        self.preview_btn = Gtk.Button()
        self.preview_btn.add_css_class('deck-button')
        self.preview_btn.add_css_class(f'btn-{self.button_data.color}')
        self.preview_btn.set_size_request(72, 72)
        self.preview_btn.set_sensitive(False)
        preview_box.append(self.preview_btn)

        self._update_preview()

        # Icon section
        icon_section = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=12)
        content.append(icon_section)

        icon_label = Gtk.Label(label="Icon")
        icon_label.add_css_class('section-title')
        icon_label.set_hexpand(True)
        icon_label.set_halign(Gtk.Align.START)
        icon_section.append(icon_label)

        self.icon_display = Gtk.Label(label=self.button_data.icon or "None")
        self.icon_display.set_size_request(40, -1)
        icon_section.append(self.icon_display)

        choose_icon_btn = Gtk.Button(label="Choose...")
        choose_icon_btn.connect('clicked', self._on_choose_icon)
        icon_section.append(choose_icon_btn)

        # Label entry
        label_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=8)
        content.append(label_box)

        label_label = Gtk.Label(label="Label")
        label_label.add_css_class('section-title')
        label_label.set_halign(Gtk.Align.START)
        label_box.append(label_label)

        self.label_entry = Gtk.Entry()
        self.label_entry.set_placeholder_text("Button Label")
        self.label_entry.set_text(self.button_data.label)
        self.label_entry.connect('changed', self._on_label_changed)
        label_box.append(self.label_entry)

        # Color picker using shared widget
        color_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=8)
        content.append(color_box)

        color_label = Gtk.Label(label="Color")
        color_label.add_css_class('section-title')
        color_label.set_halign(Gtk.Align.START)
        color_box.append(color_label)

        self.color_picker = ColorPickerRow(
            selected_color=self.button_data.color,
            colors=ACCENT_COLORS,
            on_change=self._on_color_changed
        )
        color_box.append(self.color_picker)

        # Action type
        action_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=8)
        content.append(action_box)

        action_label = Gtk.Label(label="Action Type")
        action_label.add_css_class('section-title')
        action_label.set_halign(Gtk.Align.START)
        action_box.append(action_label)

        action_type_strings = [label for _, label in self.ACTION_TYPES]
        self.action_type_dropdown = Gtk.DropDown.new_from_strings(action_type_strings)

        # Set current action type
        for i, (type_id, _) in enumerate(self.ACTION_TYPES):
            if type_id == self.button_data.action_type:
                self.action_type_dropdown.set_selected(i)
                break

        self.action_type_dropdown.connect('notify::selected', self._on_action_type_changed)
        action_box.append(self.action_type_dropdown)

        # Action input stack
        self.action_stack = Gtk.Stack()
        self.action_stack.set_margin_top(8)
        action_box.append(self.action_stack)

        # Command input
        command_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=8)
        command_label = Gtk.Label(label="Command")
        command_label.add_css_class('subtitle')
        command_label.set_halign(Gtk.Align.START)
        command_box.append(command_label)

        self.command_entry = Gtk.Entry()
        self.command_entry.set_placeholder_text("e.g., pactl set-source-mute @DEFAULT_SOURCE@ toggle")
        if self.button_data.action_type == "command":
            self.command_entry.set_text(self.button_data.action)
        command_box.append(self.command_entry)
        self.action_stack.add_named(command_box, "command")

        # Lighting preset dropdown
        preset_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=8)
        preset_label = Gtk.Label(label="Lighting Preset")
        preset_label.add_css_class('subtitle')
        preset_label.set_halign(Gtk.Align.START)
        preset_box.append(preset_label)

        self.presets = LightingPresetAPI.get_presets()
        preset_names = [f"{p['icon']} {p['name']}" for p in self.presets]
        self.preset_dropdown = Gtk.DropDown.new_from_strings(preset_names if preset_names else ["No presets available"])

        # Set current preset
        if self.button_data.lighting_preset_id:
            for i, preset in enumerate(self.presets):
                if preset['id'] == self.button_data.lighting_preset_id:
                    self.preset_dropdown.set_selected(i)
                    break

        preset_box.append(self.preset_dropdown)

        refresh_btn = Gtk.Button(label="Refresh Presets")
        refresh_btn.set_halign(Gtk.Align.START)
        refresh_btn.connect('clicked', self._on_refresh_presets)
        preset_box.append(refresh_btn)

        self.action_stack.add_named(preset_box, "lighting_preset")

        # Hotkey input
        hotkey_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=8)
        hotkey_label = Gtk.Label(label="Keyboard Shortcut")
        hotkey_label.add_css_class('subtitle')
        hotkey_label.set_halign(Gtk.Align.START)
        hotkey_box.append(hotkey_label)

        self.hotkey_entry = Gtk.Entry()
        self.hotkey_entry.set_placeholder_text("e.g., ctrl+shift+a")
        if self.button_data.action_type == "hotkey":
            self.hotkey_entry.set_text(self.button_data.action)
        hotkey_box.append(self.hotkey_entry)
        self.action_stack.add_named(hotkey_box, "hotkey")

        # Text input
        text_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=8)
        text_label = Gtk.Label(label="Text to Type")
        text_label.add_css_class('subtitle')
        text_label.set_halign(Gtk.Align.START)
        text_box.append(text_label)

        self.text_entry = Gtk.Entry()
        self.text_entry.set_placeholder_text("Text to input when pressed")
        if self.button_data.action_type == "text":
            self.text_entry.set_text(self.button_data.action)
        text_box.append(self.text_entry)
        self.action_stack.add_named(text_box, "text")

        # Show correct action input
        self.action_stack.set_visible_child_name(self.button_data.action_type)

    def _update_preview(self):
        preview_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=2)
        preview_box.set_halign(Gtk.Align.CENTER)
        preview_box.set_valign(Gtk.Align.CENTER)

        # Icon
        if self.button_data.icon_type == "emoji":
            icon_widget = Gtk.Label(label=self.button_data.icon or "?")
            icon_widget.add_css_class('button-icon')
        elif self.button_data.icon_type == "icon_name":
            icon_widget = Gtk.Image.new_from_icon_name(self.button_data.icon or "dialog-question-symbolic")
            icon_widget.set_pixel_size(28)
        else:
            try:
                pixbuf = GdkPixbuf.Pixbuf.new_from_file_at_scale(self.button_data.icon, 28, 28, True)
                icon_widget = Gtk.Image.new_from_pixbuf(pixbuf)
            except Exception:
                icon_widget = Gtk.Image.new_from_icon_name("dialog-question-symbolic")
                icon_widget.set_pixel_size(28)

        preview_box.append(icon_widget)

        # Label
        label = Gtk.Label(label=self.button_data.label or "LABEL")
        label.add_css_class('button-label')
        text_color = COLORS['crust'] if needs_dark_text(self.button_data.color) else 'white'
        label.set_markup(f'<span foreground="{text_color}">{self.button_data.label or "LABEL"}</span>')
        preview_box.append(label)

        self.preview_btn.set_child(preview_box)

    def _on_choose_icon(self, button):
        dialog = IconPickerDialog(
            self,
            current_icon=self.button_data.icon,
            current_type=self.button_data.icon_type,
            on_select=self._on_icon_selected
        )
        dialog.present()

    def _on_icon_selected(self, icon: str, icon_type: str):
        self.button_data.icon = icon
        self.button_data.icon_type = icon_type

        if icon_type == "emoji":
            self.icon_display.set_text(icon)
        elif icon_type == "icon_name":
            self.icon_display.set_text(icon.replace('-symbolic', ''))
        else:
            self.icon_display.set_text(Path(icon).name)

        self._update_preview()

    def _on_label_changed(self, entry):
        self.button_data.label = entry.get_text()
        self._update_preview()

    def _on_color_changed(self, color: str):
        self.preview_btn.remove_css_class(f'btn-{self.button_data.color}')
        self.button_data.color = color
        self.preview_btn.add_css_class(f'btn-{color}')
        self._update_preview()

    def _on_action_type_changed(self, dropdown, _):
        idx = dropdown.get_selected()
        if 0 <= idx < len(self.ACTION_TYPES):
            action_type = self.ACTION_TYPES[idx][0]
            self.button_data.action_type = action_type
            self.action_stack.set_visible_child_name(action_type)

    def _on_refresh_presets(self, button):
        self.presets = LightingPresetAPI.get_presets()
        preset_names = [f"{p['icon']} {p['name']}" for p in self.presets]
        model = Gtk.StringList()
        for name in preset_names:
            model.append(name)
        self.preset_dropdown.set_model(model)

    def _on_save(self, button):
        action_type = self.button_data.action_type
        action = ""
        preset_id = None

        if action_type == "command":
            action = self.command_entry.get_text()
        elif action_type == "lighting_preset":
            idx = self.preset_dropdown.get_selected()
            if 0 <= idx < len(self.presets):
                preset_id = self.presets[idx]['id']
        elif action_type == "hotkey":
            action = self.hotkey_entry.get_text()
        elif action_type == "text":
            action = self.text_entry.get_text()

        self.result = DeckButton(
            icon=self.button_data.icon,
            icon_type=self.button_data.icon_type,
            label=self.button_data.label,
            color=self.button_data.color,
            action=action,
            action_type=action_type,
            lighting_preset_id=preset_id
        )
        self.close()


class MacropadButton(Gtk.Button):
    """A single macro button."""

    def __init__(self, button: DeckButton, index: int, edit_mode: bool = False):
        super().__init__()
        self.button_data = button
        self.index = index
        self.edit_mode = edit_mode

        self.add_css_class('deck-button')
        self.add_css_class(f'btn-{button.color}')

        if edit_mode:
            self.add_css_class('edit-mode')

        self._build_content()
        self.connect('clicked', self._on_clicked)

    def _build_content(self):
        box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=2)
        box.set_halign(Gtk.Align.CENTER)
        box.set_valign(Gtk.Align.CENTER)
        self.set_child(box)

        # Icon based on type
        if self.button_data.icon_type == "emoji" or not self.button_data.icon_type:
            icon = Gtk.Label(label=self.button_data.icon or "?")
            icon.add_css_class('button-icon')
            box.append(icon)
        elif self.button_data.icon_type == "icon_name":
            icon = Gtk.Image.new_from_icon_name(self.button_data.icon or "dialog-question-symbolic")
            icon.set_pixel_size(28)
            icon.add_css_class('button-icon-image')
            box.append(icon)
        elif self.button_data.icon_type == "file_path":
            try:
                expanded_path = Path(self.button_data.icon).expanduser()
                if expanded_path.exists():
                    pixbuf = GdkPixbuf.Pixbuf.new_from_file_at_scale(str(expanded_path), 28, 28, True)
                    icon = Gtk.Image.new_from_pixbuf(pixbuf)
                else:
                    icon = Gtk.Image.new_from_icon_name("dialog-question-symbolic")
                    icon.set_pixel_size(28)
            except Exception:
                icon = Gtk.Image.new_from_icon_name("dialog-question-symbolic")
                icon.set_pixel_size(28)
            icon.add_css_class('button-icon-image')
            box.append(icon)

        label = Gtk.Label(label=self.button_data.label)
        label.add_css_class('button-label')
        # Text color based on button color
        text_color = COLORS['crust'] if needs_dark_text(self.button_data.color) else 'white'
        label.set_markup(f'<span foreground="{text_color}">{self.button_data.label}</span>')
        box.append(label)

    def _on_clicked(self, button):
        """Execute button action."""
        if self.edit_mode:
            return

        if self.button_data.action_type == "lighting_preset":
            if self.button_data.lighting_preset_id:
                run_in_thread(self._apply_lighting_preset)
        elif self.button_data.action_type == "command" and self.button_data.action:
            try:
                subprocess.Popen(
                    self.button_data.action,
                    shell=True,
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL
                )
                self._show_success()
            except Exception:
                self._show_error()
        elif self.button_data.action_type == "hotkey" and self.button_data.action:
            try:
                subprocess.Popen(
                    f"xdotool key {self.button_data.action}",
                    shell=True,
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL
                )
                self._show_success()
            except Exception:
                self._show_error()
        elif self.button_data.action_type == "text" and self.button_data.action:
            try:
                subprocess.Popen(
                    f"xdotool type '{self.button_data.action}'",
                    shell=True,
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL
                )
                self._show_success()
            except Exception:
                self._show_error()

    def _apply_lighting_preset(self):
        success = LightingPresetAPI.apply_preset(self.button_data.lighting_preset_id)
        GLib.idle_add(self._show_success if success else self._show_error)

    def _show_success(self):
        self.add_css_class('action-success')
        GLib.timeout_add(500, lambda: self.remove_css_class('action-success'))

    def _show_error(self):
        self.add_css_class('action-error')
        GLib.timeout_add(500, lambda: self.remove_css_class('action-error'))


class MacropadWindow(Adw.ApplicationWindow):
    """Main Macropad window."""

    def __init__(self, app):
        super().__init__(application=app)
        self.set_title("Aegis Macropad")
        self.set_default_size(520, 480)

        self.pages: List[List[DeckButton]] = [DEFAULT_BUTTONS.copy(), [], []]
        self.current_page = 0
        self.edit_mode = False
        self.config_path = Path.home() / ".config" / "aegis" / "macropad" / "config.json"
        self.button_widgets: List[MacropadButton] = []
        self.page_indicators: List[Gtk.Button] = []

        setup_css(self, APP_CSS)
        self._build_ui()
        self._load_config()

    def _build_ui(self):
        main_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=0)
        self.set_content(main_box)

        # Header bar
        header = Adw.HeaderBar()
        header.add_css_class('header-bar')

        # Device status
        status_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=8)

        device_icon = Gtk.Label(label="üéÆ")
        status_box.append(device_icon)

        device_info = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=0)
        device_info.set_valign(Gtk.Align.CENTER)

        device_name = Gtk.Label(label="Macropad")
        device_name.add_css_class('title')
        device_name.set_halign(Gtk.Align.START)
        device_info.append(device_name)

        self.status_label = Gtk.Label(label="‚óè Virtual")
        self.status_label.add_css_class('status-connected')
        self.status_label.set_halign(Gtk.Align.START)
        device_info.append(self.status_label)

        status_box.append(device_info)
        header.set_title_widget(status_box)

        # Edit button
        self.edit_btn = Gtk.Button(icon_name="document-edit-symbolic")
        self.edit_btn.set_tooltip_text("Edit buttons")
        self.edit_btn.connect('clicked', self._on_edit_mode_toggled)
        header.pack_end(self.edit_btn)

        # Menu button
        menu_btn = Gtk.MenuButton(icon_name="open-menu-symbolic")
        menu_btn.set_tooltip_text("Menu")

        menu = Gio.Menu()
        menu.append("Import Config", "app.import")
        menu.append("Export Config", "app.export")
        menu_btn.set_menu_model(menu)
        header.pack_end(menu_btn)

        main_box.append(header)

        # Content area
        content = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=16)
        content.set_margin_top(16)
        content.set_margin_bottom(16)
        content.set_margin_start(16)
        content.set_margin_end(16)
        main_box.append(content)

        # Deck panel
        deck_panel = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=16)
        deck_panel.add_css_class('deck-panel')
        content.append(deck_panel)

        # Button grid
        self.button_grid = Gtk.Grid()
        self.button_grid.set_row_spacing(8)
        self.button_grid.set_column_spacing(8)
        self.button_grid.set_halign(Gtk.Align.CENTER)
        deck_panel.append(self.button_grid)

        self._populate_buttons()

        # Page indicators
        page_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=8)
        page_box.set_halign(Gtk.Align.CENTER)
        page_box.set_margin_top(8)
        deck_panel.append(page_box)

        for i in range(3):
            indicator = Gtk.Button(label=str(i + 1))
            indicator.add_css_class('page-indicator')
            if i == 0:
                indicator.add_css_class('active')
            indicator.connect('clicked', self._on_page_clicked, i)
            page_box.append(indicator)
            self.page_indicators.append(indicator)

        # Category chips
        chips_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=8)
        chips_box.set_halign(Gtk.Align.CENTER)
        chips_box.set_margin_top(8)
        content.append(chips_box)

        categories = ["Streaming", "Audio", "Lighting", "System"]
        for cat in categories:
            chip = Gtk.Label(label=cat)
            chip.add_css_class('chip')
            chips_box.append(chip)

        # Setup actions
        self._setup_actions()

    def _setup_actions(self):
        """Setup application actions."""
        import_action = Gio.SimpleAction.new("import", None)
        import_action.connect("activate", self._on_import_config)
        self.get_application().add_action(import_action)

        export_action = Gio.SimpleAction.new("export", None)
        export_action.connect("activate", self._on_export_config)
        self.get_application().add_action(export_action)

    def _populate_buttons(self):
        """Populate the button grid."""
        self.button_widgets.clear()
        while True:
            child = self.button_grid.get_first_child()
            if child is None:
                break
            self.button_grid.remove(child)

        buttons = self.pages[self.current_page] if self.current_page < len(self.pages) else []

        while len(buttons) < 15:
            buttons.append(DeckButton("", "emoji", "", "surface1", "", "command"))

        for i, btn_data in enumerate(buttons[:15]):
            row = i // 5
            col = i % 5
            btn_widget = MacropadButton(btn_data, i, self.edit_mode)
            if self.edit_mode:
                btn_widget.connect('clicked', self._on_button_edit_clicked, i)
            self.button_grid.attach(btn_widget, col, row, 1, 1)
            self.button_widgets.append(btn_widget)

    def _on_edit_mode_toggled(self, button):
        """Toggle edit mode."""
        self.edit_mode = not self.edit_mode

        if self.edit_mode:
            self.edit_btn.add_css_class('edit-btn-active')
            self.status_label.set_text("‚óè Edit Mode")
        else:
            self.edit_btn.remove_css_class('edit-btn-active')
            self.status_label.set_text("‚óè Virtual")
            self._save_config()

        self._populate_buttons()

    def _on_button_edit_clicked(self, button, index):
        """Open edit dialog for a button."""
        if not self.edit_mode:
            return

        current_buttons = self.pages[self.current_page]
        while len(current_buttons) <= index:
            current_buttons.append(DeckButton("", "emoji", "", "surface1", "", "command"))

        dialog = ButtonEditDialog(self, current_buttons[index])
        dialog.connect('close-request', lambda d: self._on_button_edit_closed(d, index))
        dialog.present()

    def _on_button_edit_closed(self, dialog, index):
        if dialog.result:
            self.pages[self.current_page][index] = dialog.result
            self._populate_buttons()
        return False

    def _on_page_clicked(self, button, page):
        """Switch to a different page."""
        self.current_page = page

        for i, indicator in enumerate(self.page_indicators):
            if i == page:
                indicator.add_css_class('active')
            else:
                indicator.remove_css_class('active')

        self._populate_buttons()

    def _load_config(self):
        """Load saved configuration."""
        try:
            if self.config_path.exists():
                with open(self.config_path) as f:
                    config = json.load(f)

                    for i, page_data in enumerate(config.get('pages', [])):
                        if i < len(self.pages):
                            self.pages[i] = [
                                DeckButton.from_dict(btn_data)
                                for btn_data in page_data.get('buttons', [])
                            ]

                    self.current_page = config.get('active_page', 0)
                    self._populate_buttons()
        except Exception as e:
            print(f"Error loading config: {e}")

    def _save_config(self):
        """Save configuration."""
        try:
            self.config_path.parent.mkdir(parents=True, exist_ok=True)
            config = {
                'pages': [
                    {'buttons': [btn.to_dict() for btn in page]}
                    for page in self.pages
                ],
                'active_page': self.current_page
            }
            with open(self.config_path, 'w') as f:
                json.dump(config, f, indent=2)
        except Exception as e:
            print(f"Error saving config: {e}")

    def _on_import_config(self, action, param):
        """Import configuration from file."""
        dialog = Gtk.FileDialog()
        dialog.set_title("Import Configuration")

        filter_json = Gtk.FileFilter()
        filter_json.add_pattern("*.json")
        filter_json.set_name("JSON files")

        filters = Gio.ListStore.new(Gtk.FileFilter)
        filters.append(filter_json)
        dialog.set_filters(filters)

        dialog.open(self, None, self._on_import_file_selected)

    def _on_import_file_selected(self, dialog, result):
        try:
            file = dialog.open_finish(result)
            if file:
                with open(file.get_path()) as f:
                    config = json.load(f)

                for i, page_data in enumerate(config.get('pages', [])):
                    if i < len(self.pages):
                        self.pages[i] = [
                            DeckButton.from_dict(btn_data)
                            for btn_data in page_data.get('buttons', [])
                        ]

                self._populate_buttons()
                self._save_config()
        except Exception:
            pass

    def _on_export_config(self, action, param):
        """Export configuration to file."""
        dialog = Gtk.FileDialog()
        dialog.set_title("Export Configuration")
        dialog.set_initial_name("macropad-config.json")
        dialog.save(self, None, self._on_export_file_selected)

    def _on_export_file_selected(self, dialog, result):
        try:
            file = dialog.save_finish(result)
            if file:
                config = {
                    'pages': [
                        {'buttons': [btn.to_dict() for btn in page]}
                        for page in self.pages
                    ],
                    'active_page': self.current_page
                }
                with open(file.get_path(), 'w') as f:
                    json.dump(config, f, indent=2)
        except Exception:
            pass


class MacropadApp(Adw.Application):
    def __init__(self):
        super().__init__(
            application_id='com.aegis.macropad',
            flags=Gio.ApplicationFlags.FLAGS_NONE
        )

    def do_activate(self):
        win = MacropadWindow(self)
        win.present()


def main():
    app = MacropadApp()
    app.run()


if __name__ == '__main__':
    main()
